class AnimatedEntity(Entity, Actor):
    def __init__(self, model, animations=None, **kwargs):
        Actor.__init__(self, model, animations)
        self.entity = Entity(model=None, input=self.input,update=self.update,**kwargs)
        self.entity.model = self
        self.current_anim=None

    @property
    def model(self):
        return self.entity.model

    @model.setter
    def model(self, value):
        self.entity.model = value

    def LerpAnim(self,toanim,rate=1,part=None):
        current=self.get_current_anim()
        self.enableBlend()
        self.setPlayRate(rate,toanim,partName=part)
        if toanim==self.current_anim:
            pass     
        elif self.current_anim!=None:
            self.loop(toanim, partName=part)
            Interv=LerpAnimInterval(self, 0.25, self.current_anim, toanim, partName=part)
            Interv.start()
        elif self.current_anim==None:
            self.loop(toanim, partName=part)
            Interv=LerpAnimInterval(self, 0.25, current, toanim, partName=part)
            Interv.start()
        else: #This part doesnt work
            print(f"No animtion with name {toanim} found")
        self.current_anim=toanim

    def input(self,key):
        pass
    def update(self):
        pass

class Character(AnimatedEntity):
    def __init__(self, **kwargs):
        super().__init__(parent=Harlod,model=Player, position=(0,.9,1),rotation=(0,180,0),scale=0.018,**kwargs)
        self.loop("idle")

    def input(self, key):
        if key=='w':
            self.LerpAnim(toanim="walk")
        elif key=='w' and held_keys['shift']:
            self.LerpAnim(toanim="run")
        elif held_keys['w'] and key=='shift':
            self.LerpAnim(toanim="run")
        elif held_keys['shift'] and key=='s':
            self.LerpAnim(toanim="walk backwards")
        elif held_keys['shift'] and key=='w':
            self.LerpAnim(toanim="walk")
        elif key=='a':
            self.LerpAnim(toanim="strafe left")
        elif key=='d':
            self.LerpAnim(toanim="strafe right")
        elif key=='s':
            self.LerpAnim(toanim="walk backwards")
        elif key=='s' and held_keys['shift']:
            self.LerpAnim(toanim="run backwards")
        elif key=='shift' and held_keys['s']:
            self.LerpAnim(toanim="run backwards")
        elif key == 'd up' and not held_keys['a'] and not held_keys['s'] and not held_keys['w']:
            self.LerpAnim(toanim="idle")
        elif key == 'a up'and not held_keys['d'] and not held_keys['s'] and not held_keys['w']:
            self.LerpAnim(toanim="idle")
        elif key == 's up'and not held_keys['a'] and not held_keys['d'] and not held_keys['w']:
            self.LerpAnim(toanim="idle")
        elif key == 'w up'and not held_keys['a'] and not held_keys['s'] and not held_keys['d']:
            self.LerpAnim(toanim="idle")
        elif key=='shift up' and held_keys['w']:
            self.LerpAnim(toanim="walk")
        elif key=='shift up' and held_keys['s']:
            self.LerpAnim(toanim="walk backwards")

    def update(self):
        global health_regen_timer
        if held_keys['shift'] and held_keys['w'] and not held_keys['s']:
            if not health_bar_1.value == 0:
                Harlod.speed = player_runSpeed * jump
                health_bar_1.value -= 0.25
                health_regen_timer = 0
        elif held_keys['shift'] and held_keys['s'] and not held_keys['w']:
            if not health_bar_1.value == 0:
                Harlod.speed = player_jogSpeed * jump
                health_bar_1.value -= 0.25
                health_regen_timer = 0
        elif health_regen_timer >= 2:
            if health_bar_1.value < 100:
                health_bar_1.value += time.dt  * 10
        else:
            Harlod.speed = player_walkSpeed * jump
            health_regen_timer += time.dt


sus=Entity()
class Nextbot(Entity):
    def __init__(self, texture, chase_sound, death_sound, death_texture, chase_speed, wonder_speed, **kwargs):
        super().__init__(
            parent=sus,
            model='quad',
            texture=texture,
            scale=(3, 3),
            collider='box',
            y=2,
            double_sided=True,
            **kwargs
            )
        self.chase_sound = chase_sound
        self.speed = chase_speed
        self.speed2 = wonder_speed
        self.death_sound = death_sound
        self.killed_sound = death_sound
        self.death_texture = death_texture
        self.move = None
        self.in_range = None
        self.dist = 0
        self.max_distance = 30
        self.Nextbot_rotate()
        self.chase_sound.volume = 0
        self.chase_sound.play()
        self.PhonkDeath = Entity(visible=False, model='quad', texture=self.death_texture, parent=camera.ui, scale=(2, 2))

    def update(self):
        self.dist = distance(Harlod.position, self.position)
        volume = max(1 - self.dist / self.max_distance, 0)
        self.chase_sound.volume = volume

        if 1.2 < self.dist < 18:
            self.move = False
            self.in_range = True
            self.look_at_2d(Harlod.position, 'y')
            self.position += self.forward * time.dt * self.speed
        elif self.dist < 1.2:
            if not self.killed_sound.playing:
                self.killed_sound.play()
                self.PhonkDeath.visible=True
                Harlod.y = 70
                obungaafterscarexpos = Harlod.x - 20
                self.x = obungaafterscarexpos
                invoke(self.playerdeath, delay=2)
        elif self.dist > 18:
            self.in_range = False

        if self.move:
            self.position += self.forward * time.dt * self.speed2

    def playerdeath(self):
        global playerdeath, deathL
        self.PhonkDeath.visible=False
        self.death_sound.play()
        editor_camera.enabled = True
        respawn_screen()
        deathL = editor_camera.add_script(SmoothFollow(target=Harlod, offset=(0, 2, -10)))
        playerdeath = True

    def Nextbot_move(self):
        if self.dist > 18:
            self.move = True
        invoke(self.Nextbot_rotate, delay=ra.uniform(1, 3))

    def Nextbot_rotate(self):
        self.move = False
        delay = ra.uniform(1, 3)
        if self.dist > 18 and not self.in_range:
            rotate_interval = LerpHprInterval(self, delay, (ra.uniform(0, 260), 0, 0))
            rotate_interval.start()
        invoke(self.Nextbot_move, delay=delay)

